When you start a program, the operating system (OS) allocates a chunk of memory for that program, and a single OS thread to run the program. The program is loaded into that memory and the thread begins execution. The code in the program may choose to create tasks and additional threads to run those tasks, but if this doesn’t happen, by default there is only a single thread that drives that program.

Operating systems have tools that allow you to look at their running processes. You’ll notice that there are a *lot* of processes; far more than the CPU cores you have available. How are processing resources allocated to all these processes?

Some things are fairly straightforward. For example, if your mouse is just sitting untouched, the process that handles mouse actions remains asleep. The operating system is still checking the status of the mouse to see if anything has changed, but it is only checking a flag. That is, it is *not* performing a context switch (recovering the stack) and continuing the process to check the mouse, then performing a suspension by storing the stack. When you use your mouse, an interrupt occurs and the *interrupt service routine* changes the flag so the next time the OS checks it sees that the mouse task should be resurrected. This prevents the OS from bogging down by constantly suspending and resuming the mouse process just to discover that nothing has happened.